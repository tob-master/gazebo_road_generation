%
%% Kapitel: Kapitel 4
%%======================================================================

\chapter{Erzeugung von simulierten Verkehrssitationen}
\label{cha:Erzeugung von simulierten Verkehrssitationen} \index{Erzeugung von simulierten Verkehrssitationen}

Um ein Testen der Bildverarbeitungsalgorithmen zu ermöglichen soll eine Simulationsumgebung implementiert werden. Mit der in \ref{cha:Auswahl der Entwicklungsumgebung}  ausgewählten Simulationsumgebung Gazebo wurde dafür eine Fahrbahn und ein mit einem Controller gesteuertes Fahrzeug mit Kamera implementiert. In diesem Kapitel wird der Aufbau und die Verwendung der Simulationsumgebung näher beschrieben.


\section{Erstellung der Fahrbahn}
\label{sec:Erstellung der Fahrbahn}

Mit Gazebo ist es möglich Bilddateien durch OGRE (Object-Oriented Graphics Rendering Engine) in die Simulationsumgebung einzuladen und entsprechend darzustellen. Es bedurfte eines geeigneten Software-Werkzeugs um eine Fahrbahn entsprechend den Regeln des Carolo-Cups zu modellieren.
Vektorbasierte 2D-Grafiken können zum Beispiel mit Inkscape oder Adobe Illustrator designt werden wie es in \cite{gazebovrepeval} getan wurde. Auch wäre es denkbar die 3D-Grafiksuit Blender oder ein entsprechendes CAD-Programm zu verwenden. Um es dem Anwender zu vereinfachen wurde sich aber für eine andere Methode entschieden. Cairo ist eine 2D-Grafikbibliothek. Sie ermöglicht es vektorbasierte Grafiken zu erzeugen. Mit der Python-API von Cairo namens Pycairo wurde die Erzeugung von Fahrbahnsegmenten automatisiert. Die Idee war es einen Modularen Aufbau von Fahrbahnsegmenten zu realisieren, welche durch Pycario erzeugt und automatisiert in das Gazebo-Modell-Format konvertiert und über das Gazebo-Client-Interface zusammengefügt werden können. Dazu wurden für jedes Modell der Fahrbahn Python-Skripte geschrieben, welche Bilddateien im PNG-Format für jede Fahrsituation erzeugen. Im Folgenden werden diese einzelnen Python-Skripte näher beschrieben.


\begin{enumerate}

\item[] \textbf{Gerade Strecken} \hfill \\
Als Eingabeparameter nimmt das Skript die Länge der Fahrbahn und den Offset für den Start der Mittellinienrasterung entgegen. Anschließend speichert es das Segment in einer PNG-Datei. Die Breite der Fahrspuren beträgt in der Simulation 400mm. Die Mittel- und Außenlinien besitzen eine Breite von 20mm. Die länge einer Mittellinie ist mit 200mm bemessen, genau wie auch deren Abstand untereinander.

\begin{figure}[H]
\begin{center}
  \includegraphics[width=0.3\textwidth]{/home/tb/Desktop/Master/BA_TB/02_Arbeit_Latex/006_Kapitel5/Bilder/straight_1m}% keine extention: wählt jpg für DVI
  \caption[Gerades Streckensegment]%
           {\label{fig:GeradeSrecke}%
           Gerades Streckensegment}
\end{center}
\end{figure}



\item[] \textbf{Kurven}\hfill \\
Als Eingangsparameter nimmt das Skript den Radius der Kurve entgegen, wie auch den Offset der Mittellinienrasterung. Anschließend speichert es das Segment in einer PNG-Datei.
Die Kurvensegmente besitzen die selbe Dimensionierung wie die geraden Streckenabschnitte.

\begin{figure}[H]
\begin{center}
  \includegraphics[width=0.3\textwidth]{/home/tb/Desktop/Master/BA_TB/02_Arbeit_Latex/006_Kapitel5/Bilder/Kurve}% keine extention: wählt jpg für DVI
  \caption[Kurvensegment]%
           {\label{fig:Kurve}%
           Kurvensegment}
\end{center}
\end{figure}



\item[] \textbf{Ziellinie}\hfill \\
Dieses Skript erzeugt die Startlinie ohne Eingabeparameter.
Die Startlinie besteht aus einem karierten Muster welches aus Quadraten mit 50mm Seitenlänge aufgebaut ist.

\begin{figure}[H]
\begin{center}
  \includegraphics[width=0.5\textwidth]{/home/tb/Desktop/Master/BA_TB/02_Arbeit_Latex/006_Kapitel5/Bilder/ziel}% keine extention: wählt jpg für DVI
  \caption[Zielliniensegment]%
           {\label{fig:Zielliniensegment}%
           Zielliniensegment}
\end{center}
\end{figure}

\item[] \textbf{Geschwindigkeitsbegrenzungen}\hfill \\
Als Eingangsparameter nimmt das Skript den Wert der Geschwindigkeitsbegrenzung entgegen. Anschließend speichert es das Segment in einer PNG-Datei. Auf der Fahrbahn besitzen die Markierungen eine Höhe von 400mm und eine Breite von 150mm.

\begin{figure}[H]
\begin{center}
  \includegraphics[width=0.5\textwidth]{/home/tb/Desktop/Master/BA_TB/02_Arbeit_Latex/006_Kapitel5/Bilder/roadspeedsigngs}% keine extention: wählt jpg für DVI
  \caption[Geschwindigkeitsbegrenzungssegmente]%
           {\label{fig:Geschwindigkeitsbegrenzungssegmente}%
           Geschwindigkeitsbegrenzungssegmente}
\end{center}
\end{figure}


\item[] \textbf{Zebrastreifen}\hfill \\
Das Skript erzeugt einen Zebrastreifen ohne Eingabeparameter.
Die einzelnen Streifen besitzen eine Breite von 40mm und eine Höhe von 400mm. 

\begin{figure}[H]
\begin{center}
  \includegraphics[width=0.3\textwidth]{/home/tb/Desktop/Master/BA_TB/02_Arbeit_Latex/006_Kapitel5/Bilder/crosswalk}% keine extention: wählt jpg für DVI
  \caption[Zebrastreifensegment]%
           {\label{fig:Zebrastreifensegment}%
           Zebrastreifensegment}
\end{center}
\end{figure}

\item[] \textbf{Kreuzungen}\hfill \\
Die verschiedenen Arten möglicher Kreuzungen wurden aus einzelnen durch Pycairo erzeugten Modulen in Inkscape zu einer Einheit zusammengeführt.

\begin{figure}[H]
\begin{center}
  \includegraphics[width=0.3\textwidth]{/home/tb/Desktop/Master/BA_TB/02_Arbeit_Latex/006_Kapitel5/Bilder/crossings}% keine extention: wählt jpg für DVI
  \caption[Kreuzungssegmente]%
           {\label{fig:Kreuzungssegmente}%
           Kreuzungssegmente}
\end{center}
\end{figure}


\item[] \textbf{Startbox und Parkbereich}\hfill \\
Der Parkbereich wurde zusammen mit der Startbox aus einzelnen Pycairo-Modulen in Inkscape zusammengeführt. Da diese Segmente immer gleich aufgebaut sind, werden keine Eingabeparameter benötigt. 

\begin{figure}[H]
\begin{center}
  \includegraphics[width=0.7\textwidth]{/home/tb/Desktop/Master/BA_TB/02_Arbeit_Latex/006_Kapitel5/Bilder/start_of_track}% keine extention: wählt jpg für DVI
  \caption[Startbox- und Parkbereichsegment]%
           {\label{fig:SBPBSegment}%
           Startbox- und Parkbereichsegment}
\end{center}
\end{figure}


\item[] \textbf{Verkehrsinseln}\hfill \\
Die Verkehrsinseln wurden aus einzelnen Pycairo-Modulen mit Inkscape zusammengführt.

\begin{figure}[H]
\begin{center}
  \includegraphics[width=0.5\textwidth]{/home/tb/Desktop/Master/BA_TB/02_Arbeit_Latex/006_Kapitel5/Bilder/islands}% keine extention: wählt jpg für DVI
  \caption[Verkehrsinselsegmente]%
           {\label{fig:Verkehrsinselsegmente}%
           Verkehrsinselsegmente}
\end{center}
\end{figure}

\item[] \textbf{Linienverdeckungsfläche}\hfill \\
Es können schwarze rechteckige Flächen erzeugt werden, welche zum Verdecken von Fahrlinien verwendet werden können. Die Eingangsparameter sind die Höhe und Breite der Fläche.

\item[] \textbf{Verkehrsschilder}\hfill \\
Die im Carolo-Cup möglichen Verkehrsschilder wurden aus dem Github-Repository von tum-phoenix entnommen \cite{tum}.

\begin{figure}[H]
\begin{center}
  \includegraphics[width=0.7\textwidth]{/home/tb/Desktop/Master/Bilder/alleSchilder}% keine extention: wählt jpg für DVI
  \caption[Verkehrsschilder des CaroloCups]%
           {\label{fig:Verkehrsschilder}%
           Verkehrsschilder des CaroloCups}
\end{center}
\end{figure}


\item[] \textbf{Abbiegepfeile}\hfill \\
Der Abbiegepfeil wurde dem Github-Repository von tum-phoenix entnommen \cite{tum}.
\end{enumerate}


\begin{figure}[H]
\begin{center}
  \includegraphics[width=0.1\textwidth]{/home/tb/Desktop/Master/Bilder/abbiegepfeil}% keine extention: wählt jpg für DVI
  \caption[Abbiegepfeile]%
           {\label{fig:Abbiegepfeile}%
           Abbiegepfeile}
\end{center}
\end{figure}






Das Verh\"altnis an Bildpixeln pro Meter in der Simulationsumgebung wurde dabei in den Python-Skripten auf 500 festgelegt. Dies ermöglicht eine scharfe Ansicht der Module in der Simulationsumgebung, wobei nicht allzu viel Rechenleistung für das Rendering benötigt wird. Mit dem Python-Skript create\_model\_on\_box können die Fahrbahn-Module (PNG-Dateien) automatisiert in das Gazebo-Modell-Format (SDF) konvertiert werden.
Dafür muss der Dateiname, der Speicherort und das Auflösungsverhältnis als Eingabeparameter dem Skript übergeben werden. Dieses erzeugt die entsprechende Modell-Datei und kopiert sie in den Gazebo-Modell-Ordner (.gazebo/models). Nach dem Starten des Gazebo-Clients können die Module im Reiter Insert gefunden und zu einer Fahrbahn zusammengeführt werden. 

\begin{figure}[H]
\begin{center}
  \includegraphics[width=0.5\textwidth]{/home/tb/Desktop/Master/Bilder/rotateFahrbahn}% keine extention: wählt jpg für DVI
  \caption[ Einfügen eines Kreuzungssegments in den Gazebo-Simulator]%
           {\label{fig:GazeboKreuzungModel}%
           Einfügen eines Kreuzungssegments in den Gazebo-Simulator}
\end{center}
\end{figure}


Desweitern können dreidimensionale Boxen direkt im Gazebo-Client eingefügt werden. Diese werden zum Beispiel für Parklücken benötigt.

\begin{figure}[H]
\begin{center}
  \includegraphics[width=0.5\textwidth]{/home/tb/Desktop/Master/Bilder/box}% keine extention: wählt jpg für DVI
  \caption[Einfügen eines Parklückenhindernisses in den Gazebo-Simulator]%
           {\label{fig:GazeboBoxModel}%
           Einfügen eines Parklückenhindernisses in den Gazebo-Simulator}
\end{center}
\end{figure}

Nach beenden der Fahrbahnmodellierung, kann die Fahrbahn durch den Gazebo-Client als World-Datei im SDF-Format gespeichert werden.

\begin{figure}[H]
\begin{center}
  \includegraphics[width=0.7\textwidth]{/home/tb/Desktop/Master/Bilder/driveTrack}% keine extention: wählt jpg für DVI
  \caption[Modularer Aufbau eines gesamten Rundkurses im Gazebo-Simulator}]%
           {\label{fig:GazeboRundkursWorld}%
           Modularer Aufbau eines gesamten Rundkurses im Gazebo-Simulator}
\end{center}
\end{figure}



https://github.com/gkouros/ackermann-drive-teleop


\section{Erstellung des Fahrzeugs}
\label{sec:Erstellung der Fahrzeugs}

Die Modellierung des Fahrzeugs wurde mit dem ROS-Package ackermann\_vehicle\_gazebo \cite{ackerm} ermöglicht.
Das Package implementiert ein Fahrzeug mit Ackermann-Lenkung für ROS-Gazebo. Dafür nutzt es das Ackermann-Plugin.
Das Fahrzeug ist durch eine Modell-Datei beschrieben im SDF-Format implementiert. In dieser Modell-Datei wurden Anpassungen vorgenommen, um das Fahrzeug auf die Dimensionen des Fahrzeugs der Hochschule Karlsruhe zu bringen. Außerdem wurde es um ein Kamera-Plugin erweitert, um Rosbags in der Simulation aufnehmen zu können. Folgende Parameter lassen sich darüber einstellen:

\begin{enumerate}

\item[] \textbf{imageTopicName} \hfill \\
Legt den Namen der Topic fest, auf welche Kamera-Bilder gepublisht werden.

\item[] \textbf{update\_rate} \hfill \\
Legt die Frame-Rate fest in der Bilder auf die Kamera-Topic gepublisht werden.

\item[] \textbf{horizontal\_fov} \hfill \\
Legt den horizontalen Blickwinkel der Kamera fest.

\item[] \textbf{image\_width} \hfill \\
Legt die Bildbreite fest.

\item[] \textbf{image\_height} \hfill \\
Legt die Bildhöhe fest.

\item[] \textbf{image\_type} \hfill \\
Legt den Bild-Typ fest (zum Beispiel Graustufenbild).

\item[] \textbf{clip\_near} \hfill \\
Legt die minimale Sichtweite fest.


\item[] \textbf{clip\_far} \hfill \\
Legt die maximale Sichtweite fest

\item[] \textbf{noise\_type} \hfill \\
Legt eine Art von Rauschen auf das Bild (zum Beispiel Gaußsches Rauschen).

\item[] \textbf{noise\_mean} \hfill \\
Legt den Mittelwert des Rauschens fest.

\item[] \textbf{noise\_stddev} \hfill \\
Legt die Standardabweichung des Rauschens fest


\end{enumerate}


Das Steuern des Fahrzeugs ist über das ROS-Package joy realisiert. Durch dieses kann das Fahrzeug über einen Controller manuell gesteuert werden. In Zukunft könnte auch eine autonome Fahrt durch publishen von Fahrinformationen auf die joy-Topic realisiert werden.
Über Blender wurden zudem die im Wintersemester 18/19 erzeugten CAD-Konstruktionsteile im STL-format zusammengeführt. In Blender konnte daraus ein Mesh im Format COLLADA erzeugt werden. COLLADA ist ein XML-basiertes Austausch Format für 3D-Programme. Das durch Blender erzeugte Mesh kann zusammen mit dem ackermann\_vehicle\_gazebo-Package genutzt werden um das Carolo-Cup-Fahrzeug in der Simulation darzustellen.


\begin{figure}[H]
\begin{center}
  \includegraphics[width=0.5\textwidth]{/home/tb/Desktop/Master/Bilder/car.png}% keine extention: wählt jpg für DVI
  \caption[Das in Gazebo simulierte Fahrzeug nach dem vorhandenen CAD-Modell]%
           {\label{fig:GazeboFahrzeug}%
           Das in Gazebo simulierte Fahrzeug nach dem vorhandenen CAD-Modell}
\end{center}
\end{figure}
